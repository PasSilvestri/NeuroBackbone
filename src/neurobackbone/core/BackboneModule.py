import inspect
import sys
import os
import json
import pickle
import math
import random
from datetime import datetime
from typing import List
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import DataLoader
from torch.utils.data import Dataset
from tqdm import tqdm
import matplotlib.pyplot as plt

from neurobackbone.hooks import *

class BackboneModule(nn.Module):
    """
    The base module for constructing and managing a neural network with Backbone.
    """
    def __init__(self):
        """
        Initializes the backbone module. This method is meant to be called in the constructor of the derived class and
        will take care of managing all the parameters and submodules of the network in oreder to save it and load it correctly.
        """
        super().__init__()

        _,_,_,kwargs = inspect.getargvalues(inspect.currentframe().f_back)
        kwargs.pop("self"); kwargs.pop("__class__")
        kwargs.update(kwargs.pop("kwargs",{}))
        args = kwargs.pop("args",[]) # Those aren't supported, too much trouble for a never occuring case

        self.device = torch.device("cpu")
        self.uuid = f"{int(datetime.now().timestamp()*1000)}"

        # construction data
        self.construction_args = {
            "current": {
                "class": self.__class__.__name__,
                "module": inspect.getmodule(self).__name__,
                "uuid": self.uuid,
                "kwargs": {},
                # "args": []
            },
            "modules": {}
        }

        for key, value in kwargs.items():
            if isinstance(value,BackboneModule):
                self.construction_args["modules"][key] = value
            else:
                self.construction_args["current"]["kwargs"][key] = value
        
    def name(self):
        """
        A function that generates a formatted name using the class name and UUID.
        """
        return f"{self.__class__.__name__}_{self.uuid}"
    
    def to(self, device):
        """
        Moves the module and all its submodules to the specified device.

        Args:
            device (str): The device to move the module and submodules to.
        Returns:
            self: The updated module.
        """
        super().to(device)
        self.device = device
        for val in self._modules.values():
            if isinstance(val,(BackboneModule)):
                val.to(device)
        return self

    def __set_uuid(self,uuid):
        """
        Set the UUID attribute for the object and update construction_args with the new UUID. Used when loading an already initialized module.
        Never call this method manually.
        
        Args:
            uuid (any): The new UUID to set for the object.
        Returns:
            None
        """
        self.uuid = uuid
        self.construction_args["current"]["uuid"] = uuid
    
    @staticmethod
    def __get_class(module_construction_args):
        """
        A static method to retrieve the subclass implementing the Backbone module.
        Never call this method manually.

        Args:
            module_construction_args (dict): The dictionary containing construction arguments about the module. Is automatically generated by a BackboneModule.
                - "current" (dict): A dictionary containing information about the current module and class.
                    - "module" (str): The name of the current module.
                    - "class" (str): The name of the class to retrieve.

        Returns:
            class: The class retrieved based on the provided module construction arguments.
        """
        mod = sys.modules[module_construction_args["current"]["module"]]
        return getattr(mod,module_construction_args["current"]["class"])
    
    def __serialize(self):
        """
        Serialize the module and its submodules's arguments in order to save them.
        
        Returns:
            The serialized data as dictionary.
        """

        out = {
            "current": self.construction_args["current"],
            "modules": {}
        }
        for module_name, module in self.construction_args["modules"].items():
            out["modules"][module_name] = module.serialize()

        return out
    
    @classmethod
    def __load_module(cls, construction_args):
        """
        Recursivelly load this module and all its submodules.
        Never call this method manually.

        Args:
            cls: The subclass implementing the backbone module.
            construction_args: Its construction arguments.

        Returns:
            The loaded module.
        """
        kwargs = {}
        kwargs.update(construction_args["current"]["kwargs"])
        for module_name, module_construction_args in construction_args["modules"].items():
            kwargs[module_name] = BackboneModule.__get_class(module_construction_args).load_module(module_construction_args)
        module = cls(**kwargs)
        module.__set_uuid(construction_args["current"]["uuid"])
        module.on_load()
        return module

    def on_save(self,path):
        """Called before the module gets serialized. Override this if you want to do something when the module is loaded

        Args:
            path (str): the directory where the module has been saved
        """
        return
    
    def on_load(self):
        """Called after the module gets loaded from memory. Override this if you want to do something when the module is loaded
        """
        return
    
    def save(self, path="./"):
        """
        Saves the module's structure to a text file, module's arguments to a JSON file (or pickle file if JSON fails), and the module's state dictionary to a .pth file.

        Args:
            path (str): The directory path where the model will be saved. Defaults to current directory if not provided.

        Returns:
            torch.save: Saves the model's state dictionary to a file.
        """
        self.on_save(path)
        to_save = self.__serialize()
        
        os.makedirs(path, exist_ok=True)
        with open(os.path.join(path,"model_structure.txt"), "w") as f1:
            f1.write(f"{self}\n")
        try:
            with open(os.path.join(path,"model_arguments.json"), "w") as f2:
                json.dump(to_save, f2, indent="\t")
        except:
            with open(os.path.join(path,"model_arguments.json"), "wb") as f2:
                pickle.dump(to_save, f2)
        return torch.save(self.state_dict(),os.path.join(path,"model.pth"))
    
    @classmethod
    def load(cls, path, strict:bool = True):
        """
        Load a module from the specified folder path.

        Args:
            path (str): The folder path containing the model files (model.pth and model_arguments.json).
            strict (bool, optional): Whether to strictly load the model. Defaults to True.

        Returns:
            model: The loaded module.
        """
        state_dict = torch.load(os.path.join(path,"model.pth"), map_location=torch.device('cpu'))
        construction_args = {
            "current": {
                "class": cls.__name__,
                "module": inspect.getmodule(cls).__name__,
                "uuid": f"{int(datetime.now().timestamp()*1000)}",
                "kwargs": {},
                # "args": []
            },
            "modules": {}
        }
        try:
            with open(os.path.join(path,"model_arguments.json"), "r") as f:
                construction_args = json.load(f) 
        except:
            with open(os.path.join(path,"model_arguments.json"), "rb") as f:
                construction_args = pickle.load(f) 
 
        model = cls.__load_module(construction_args)
        model.load_state_dict(state_dict, strict=strict)
        return model






